{"body":"editor.rb is a text editor writen in ruby/curses.\r\n\r\nDesign goals:\r\n\r\n1. Zero install\r\n\t- single file of ruby code\r\n\t- only use built-in libraries (hence curses instead of ncurses)\r\n2. Easy to modify, customize & extend\r\n3. Scriptable\r\n\t- execute single-line ruby commands within the editor\r\n\t- execute ruby script files from within the editor\r\n\t- execute ruby script files at startup\r\n\r\n\r\n\r\nUsage\r\n=====\r\n\r\nInstalling & running\r\n--------------------\r\n\r\nFrom easy to hard:\r\n\r\n1. Just run \"ruby editor.rb\".\r\n\r\n2. Put editor.rb in your path and give it execute permission.\r\nRename it whatever you like.\r\n\r\n3. (This is what I do) I create a directory ~/.jedi (jedi = Jason's EDItor)\r\ncontaining the files config.rb and history.yaml.  It also contains a directory\r\ncalled snippets.  Snippets is where I keep snippets of useful code for\r\nmodifying text.  Then I put the following line in my .bashrc file:\r\n\r\n\talias jedi='ruby $HOME/bin/editor.rb -s $HOME/.jedi -y $HOME/.jedi/history.yaml'\r\n\r\nThis tells editor.rb to read all *.rb files from ~/.jedi/ as scripts and to\r\nsave command/search/script history in ~/.jedi/history.yaml.\r\n\r\n\r\nOptions\r\n-------\r\n\r\nA few parameters and flags, (such as tab size, and autoindent)\r\ncan be set with command line options.  Type \"ruby editor.rb -h\" to see\r\navailable options.\r\n\r\n\r\nConfiguration\r\n-------------\r\n\r\nThe code does not parse a configuration file per se.  Because ruby\r\nsupports metaprogramming, configuration and modification/extension\r\nare all the same.\r\n\r\nThe \"-s\" or \"--script\" option calls a script or set of scripts to\r\nbe run at startup.  This can be used to set basic parameters, for example:\r\n\r\nCreate a file called \"config.rb\" containing:\r\n\r\n\t$tabsize = 8\r\n\t$autoindent = true\r\n\t$syntax_color = false\r\n\r\nAnd start the editor with \"-s config.rb\" set.\r\n\r\nOne can do more complex configurations, such as swapping keybindings.\r\nSuppose you like to use nano's \"ctrl-x\" for quit, rather than\r\n\"ctrl-q\":\r\n\r\n\t$keymap.commandlist[$ctrl_x] = \"buffer = $buffers.close\"\r\n\t$keymap.commandlist[$ctrl_q] = \"buffer.mark\"\r\n\r\nOne can go even further, and modify/create class methods.  For example,\r\nif you prefer that ctrl-e take you to the last character of the line,\r\nrather than just past the last character:\r\n\r\n\tclass FileBuffer\r\n\t\tdef cursor_eol\r\n\t\t\t@col = @text[@row].length-1\r\n\t\tend\r\n\tend\r\n\r\nHere are some other useful mods:\r\n\r\nChange the syntax coloring:\r\n\r\n\t$color_comment = $color_green\r\n\r\nMake files that end in \".h\" get c-style coloring:\r\n\r\n\t$filetypes[/\\.h$/] = \"c\"\r\n\r\nDefine a new filetype for syntax coloring\r\n\r\n\t$filetypes[/\\.abc$/] = \"abc\"\r\n\t$syntax_color_lc[\"abc\"] = [\"||\"]\r\n\t$syntax_color_bc[\"abc\"] = {\"|+\"=>\"+|\"}\r\n\t$syntax_color_regex[\"abc\"] = {/abc/=>$color_green}\r\n\r\nAs you can see, this can be used for simple configuration, or to create\r\nmods/extenstions to the editor.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nModes\r\n-----\r\n\r\nThis is not a modal editor, but it does have two modes.\r\nIn the \"edit\" mode you can do pretty much everything.\r\nIn the \"view\" mode, you cannot modify the text (not strictly true),\r\nand there are some shorcuts for navigation, such as:\r\n\t- h,j,k,l to move the cursor\r\n\t- space, b for page down/up\r\n\t- / to search\r\n\t- H,J,K,L to shift screen around\r\n\t- \",\",\".\" (unshifted >,<) to change buffers\r\n\t- g to goto a line\r\n\r\nTo get to view mode, hit \"ctrl-t v\". To get to edit mode, hit\r\n\"ctrl-t e\" or just hit \"i\".  There are some commans only available\r\nin view mode, because of the limited number of keys on the keyboard.\r\n\r\nRemember that all the keymappings can be easily changed, and one\r\ncould easily write a set of keybindings that are very vim-like.\r\n\r\n\r\n\r\nBasic editing\r\n-------------\r\n\r\nBasic editing uses control sequences similar to gnu-nano.  Some default\r\nkeybindings (easy to change):\r\n\r\n\t- Arrow keys & page up/down to move around.\r\n\t- Shift-arrow to scroll the page\r\n\t- Ctrl-{v,y} are also page down/up.\r\n\t- Ctrl-w to search\r\n\t- Ctrl-r search & replace\r\n\t- Ctrl-o to save\r\n\t- Ctrl-q to close file (quit if only one file open)\r\n\t- Ctrl-e end of line\r\n\t- Ctrl-a start of line\r\n\t- Ctrl-d delete character\r\n\t- Ctrl-l next text buffer\r\n\t- Ctrl-f open file\r\n\t- Ctrl-g go to line number (empty=0, negative = up from bottom)\r\n\t- Ctrl-p copy\r\n\t- Ctrl-k cut\r\n\t- Ctrl-u paste\r\n\t- Ctrl-c cancel operation\r\n\t- Ctrl-t toggle various things\r\n\t\t- e = edit mode\r\n\t\t- v = view mode\r\n\t\t- a = autoindent\r\n\t\t- m = manual indent\r\n\t\t- i = insert mode\r\n\t\t- o = overwrite mode\r\n\t\t- c = column mode\r\n\t\t- r = row mode\r\n\t\t- s = syntax coloring on\r\n\t\t- b = syntax coloring off\r\n\t\t- - = split screen vertically\r\n\t\t- | = split screen horizontally\r\n\t- Ctrl-x mark text\r\n\t- Ctrl-^ N to move buffer to screen N (split screen)\r\n\t- Ctrl-^ 0 to put all buffers on same screen (or undo such a move)\r\n\t- Ctrl (left|right) arrow = undo/redo\r\n\t- Ctrl-Shift (left|right) arrow = revert/unrevert to saved\r\n\r\n\r\n\r\n\r\nEntering ruby commands\r\n----------------------\r\n\r\nType \"ctrl-s <ruby commands> <enter>\" to enter a ruby command.\r\nAll commands entered this way, are run in the context of the current\r\nfile buffer.  Thus \"@text\" refers to the text of that buffer.  The\r\nscreen can be accessed by the global variable \"$screen\", and the other\r\nbuffers can be accessed by the \"$buffers\" global variable.\r\n\r\nFor example:\r\n\r\nTo change the tabsize:\r\n\r\n\t@tabsize = 8\r\n\r\nTo specify that the file is a fortran file for syntax coloring:\r\n\r\n\t@filetype = 'f'\r\n\r\nTo change the color of comments from cyan to green\r\n\r\n\t$color_comment = $color_green\r\n\r\nTo change a bulleted (\"-\") list which starts on the current line and\r\nis 10 lines long to a numbered list\r\n\r\n\tk=0; @text[@row,10].each{|line|; k+=1; line=line.sub(/^(\\s*)-/,\"\\\\1#{k}.\")}\r\n\r\nTo turn a double underline to a single underline, go to the underline row:\r\n                 =========             ---------\r\n\r\n\t@text[@row] = @text[@row].gsub(\"=\",\"-\")\r\n\r\nTo underline a line of text:\r\n\r\n\t@text.insert(@row+1,\"-\"*@text[@row].length)\r\n\r\n**Important**:\r\nNotice in each of the above examples, when modifying the text buffer,\r\nI am careful to do stuff like:\r\n\r\n\t@text[@row] = @text[@row].gsub(...\r\n\r\ninstead of the more compact:\r\n\r\n\t@text[@row].gsub!(...\r\n\r\nThese are not the same command!  The first replaces the array element\r\nwith a new element; the second modifies the existing element.  This\r\nis important because of undo-redo change detection.  The first is\r\nundo-able; the second is not.\r\n\r\n\r\nRunning ruby scripts at startup\r\n------------------------------\r\n\r\nThe \"-s\" or \"--script\" option specifies script files or directories\r\ncontaining script files to be run at startup.  If it is a directory,\r\nthe all the files ending in \".rb\" are run.  These can be simple\r\nconfiguration files, like:\r\n\r\n\t@tabsize = 4\r\n\t@autoindent = false\r\n\t$color_comment = $color_green\r\n\r\nor can be modifications to the editor.  An empty method (called\r\nperbuffer_userscript) is run at the initialization of each buffer,\r\nso that the user can add startup methods to buffers.  For example,\r\nto set the tabsize to be 4 for fortran files only:\r\n\r\n\tclass FileBuffer\r\n\t\tdef perbuffer_userscript\r\n\t\t\tif @filetype == \"f\"\r\n\t\t\t\t@tabsize = 4\r\n\t\t\telse\r\n\t\t\t\t@tabsize = 8\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\r\n\r\nExamples\r\n--------\r\n\r\nSome examples of configuration files and user scripts and mods can be\r\nfound in the \"scripts\" directory.\r\n\r\n\r\nDescription of code and methods\r\n===============================\r\n\r\nKeybindings\r\n-----------\r\n\r\nThe keybindings code has four sections: commandlist,\r\nextramode_commandlist, editmode_commandlist, and viewmode_commandlist.\r\nThe first is for universal keybindings. The third only works in\r\neditmode, and the fourth works only in viewmode. The second is for\r\nextra keybindings that there isn't room for.\r\n\r\nClasses\r\n-------\r\n\r\nThe code contains four classes:\r\n\r\n1. Screen\r\n\tLow-level screen interactions\r\n2. Window\r\n\tPer-buffer screen interactions (calls to Screen class)\r\n3. FileBuffer\r\n\tContains all info and methods regarding a single file\r\n4. BuffersList\r\n\tContainer class to manage multiple buffers\r\n5. BufferHistory\r\n\tStore up snapshots for undo/redo\r\n6. KeyMap\r\n\r\n\r\n\r\nUndo-redo\r\n---------\r\n\r\nThe buffer text is stored in an array of strings (lines).  Each time\r\nthe user does something, a snapshot of the text is saved.  This\r\nsnapshot is a shallow copy (it is a new array, but each element is\r\npointer to the old string). Before a line is changed, a deep copy is\r\nmade of that line (now the array has one differing element). These\r\nsequences of snapshots are saved in a linked list (BufferHistory\r\nclass). The linked list format allows the possibility of undo-trees if\r\nI ever feel they would be useful.  Undo and redo, are as simple as\r\nbumping a pointer up or down the link list of text buffers.\r\n\r\n\r\n\r\n------------------------------------------------------------------------\r\nCopyright (C) 2011-2012, Jason P. DeVita (jason@wx13.com)\r\n\r\nCopying and distribution of this file, with or without modification,\r\nare permitted in any medium without royalty or restriction.  This file\r\nis offered as-is, without any warranty.\r\n------------------------------------------------------------------------","name":"Editor","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"a text editor","google":""}